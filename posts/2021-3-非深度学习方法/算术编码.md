## **算术编码(Arithmetic Coding)**

[blog: CACM87实现](https://marknelson.us/posts/2014/10/19/data-compression-with-arithmetic-coding.html) 

算术编码是无损和有损数据压缩算法中常用的算法。

它是一种熵编码技术，其中经常出现的符号比很少见的符号用更少的比特编码。 与霍夫曼编码等众所周知的技术相比，它具有一些优势。 本文将详细介绍算术编码的 CACM87 实现，让您很好地理解实现它所需的所有细节。

我认为理解算术编码的最好方法是将它分成两部分。 首先，我将使用常规浮点运算来描述算术编码的工作原理。 这允许一个完全可以理解但有点不切实际的实现。 换句话说，它可以工作，但它只能用于对非常短的消息进行编码。

本文的第二部分将描述一个实现，在该实现中我们切换到对无界二进制数进行特殊类型的数学运算。 这本身就是一个有点令人难以置信的话题，所以如果您已经了解算术编码，它会有所帮助——您不会因为试图同时学习两件事而束手无策。

### 第一部分

#### 基础知识

关于算术编码，首先要了解的是它产生的结果。 算术编码采用由符号（几乎总是八位字符）组成的消息（通常是文件），并将其<font color="brown">转换为大于或等于零且小于一的浮点数</font>。 这个浮点数可能很长——实际上你的整个输出文件都是一个长数——这意味着它不是你在传统编程语言中习惯使用的普通数据类型。 我的算法实现必须从头开始一点一点地创建这个浮点数，同样地读入它并一点一点地解码。

这个编码过程是增量完成的。 当文件中的每个字符都被编码时，一些位将被添加到编码消息中，因此随着算法的进行，它会随着时间的推移而建立起来。

关于算术编码要了解的第二件事是它依赖于<font color="brown">(熵)模型</font>来表征它正在处理的符号。 模型的工作是告诉编码器字符在给定消息中的概率是多少。 如果模型给出消息中字符的准确概率，它们将几乎得到最优编码。 如果模型错误地表示了符号的概率，您的编码器实际上可能会扩展消息而不是压缩消息！

#### 编码（浮点Math）

使用 C++ 双精度数据以非常有限的形式实现算法。 第一部分中的代码仅用于说明 - 不要尝试对其进行任何真正的压缩。

要执行算术编码，我们首先需要定义一个合适的模型。 请记住，模型的功能是提供消息中给定字符的概率。 算术编码模型的概念是每个符号在 0 和 1 之间的实数数轴上都有自己独特的部分。需要注意的是，有许多不同的方法可以对字符概率进行建模。 有些模型是静态的，永远不会改变。有些模型处理完每个字符后会更新。 对我们来说唯一重要的两件事是 <font color="brown">1) 模型试图准确预测字符出现的概率，以及 2) 编码器和解码器始终具有相同的模型。</font>

举个例子，我们可以从一个只能编码 100 个不同字符的字母表的编码器开始。 在一个简单的静态模型中，假设每个字符出现的概率相等。比如第一个符号“A”将拥有从 0 到 .01 的数字线，“B”将拥有 .01 到 .02，依此类推。 

比如消息中的第一个字符是“B”，这意味着消息介于 .01 和 .02 之间。消息中的下一个字符然后根据其当前对数轴的所有权进一步划分现有范围。 比如，拥有数轴最末端的其他一些字母[ .99, 1.0) 会将范围从 [.01,.02) 更改为 [.0199, .020)。 这种范围的逐步细分只是简单的乘法和加法，最好通过简单的代码示例来理解：

```cpp
double high = 1.0;
double low = 0.0;
char c;
while ( input >> c ) {
  std::pair<double, double> p = model.getProbability(c);
  double range = high - low;
  high = low + range * p.second;
  low = low + range * p.first; 
}
output << low + (high-low)/2;
```

在处理完整个消息后，我们有一个最终范围，[low, high)。 编码器在该范围的中心输出一个浮点数。

为了简单起见，这里只充实了一个熵模型的类，足以对 ASCII 字符集中的大写字母进行编码：

```cpp
struct {
  static std::pair<double,double> getProbability( char c )
  {
    if (c >= 'A' && c <= 'Z')
      return std::make_pair( (c - 'A') * .01, (c - 'A') * .01 + .01);
    else
      throw "character out of range";
  }
} model;
```

举一个代表性的例子，我们对字符串“WXYZ”使用编码器。 让我们来看看编码器中发生了什么。

我们从high和low设置为 1.0 和 0.0 开始。 编码器调用模型以获取字母“W”的概率，它返回区间 [0.22, 0.23) - 在此模型中“W”拥有的概率线上的范围。 如果您跨过接下来的两行，您会看到low现在设置为 0.22，high设置为 0.23。

如果你研究它是如何工作的，你会发现随着每个字符的编码，high和low之间的范围变得越来越窄，但high总是大于low。 此外，low 的值总是在增加，而 high 的值总是在减少。 这些<font color="brown">不变性</font>对于使算法正常工作很重要。

所以在第一个字符被编码后，我们知道无论其他值被编码，消息中的最终数字将小于 .23 并且大于或等于 .22。 low 和 high 都将大于等于 0.22 且小于 0.23，并且 low 将严格小于 high。 这意味着在解码时，<font color="brown">无论之后发生什么，我们都可以确定第一个字符是'W'</font>，因为最终编码的数字将落在'W'所拥有的范围内。

<img src="/Users/DevonnHou/Library/Application Support/typora-user-images/image-20221210173241391.png" alt="image-20221210173241391" style="zoom:36%;" />

我将更多地讨论如何选择我们想要输出的确切值，但至少在理论上，对于这段消息，区间<font color="brown"> [0.22232425,0.22232426)</font> 中的任何浮点数都应该正确解码为所需的值。

比如，最终编码消息将是`0.2223242550`。

#### 解码（浮点Math）

前面描述的编码算法非常直观。 解码器则反转了这个过程，并没有变得更复杂，但这些步骤可能看起来并不那么明显。 解码此消息的算法如下所示：

```cpp
void decode(double message)
{
  double high = 1.0;
  double low = 0.0;
  for ( ; ; ) 
  {
    double range = high - low;
    char c = model.getSymbol((message - low)/range);
    std::cout << c;
    if ( c == 'Z' )
      return;
    std::pair<double,double> p = model.getProbability(c);
    high = low + range * p.second;
    low = low + range * p.first; 
  }
}
```

解码器中的数学基本上与编码端的数学相反。 要解码一个字符，概率模型只需要找到其范围覆盖消息当前值的字符。 当解码器首先以 0.22232425 的样本值启动时，模型发现该值落在“W”所拥有的区间之间：[0.22,0.23)，因此模型返回 W。在 fp_proto.cpp 中，解码器部分 简单模型如下所示：

```cpp
static char getSymbol( double d)
{
  if ( d >= 0.0 && d < 0.26)
    return 'A' + static_cast<int>(d*100);
  else
    throw "message out of range";
}
```

在编码器中，我们在处理每个字符时不断缩小输出值的范围。 在解码器中，我们对正在检查下一个字符的消息部分进行相同的缩小。 在“W”被解码后，high 和 low 现在将定义 [0.22,0.23) 的区间，range为 .01。 因此，计算下一个要解码的概率值`(message - low)/range`的公式将为 .2324255，它恰好位于“X”所涵盖范围的中间。

随着字符被解码，这种缩小会继续，直到到达消息的硬编码(hardcoded)结尾，即字母“Z”。 成功！

**到目前为止的笔记和总结**

目前为止我们所看到的并不是真正有效或有用的编码器。 然而，它确实以一定的准确性展示了算法的一般流程。 到目前为止的主要观察结果是：

字符根据它们在概率范围 [0, 1) 中的位置进行编码。
我们使用变量 high 和 low 来跟踪当前状态。 有效的输出结果将是 [low, high) 范围内的任何数字。
在对每个字符进行编码时，它会以与其在概率范围内的位置完全对应的方式压缩范围 [low, high)。
我们有一些不变量来自算法中使用的数学。 low 的值永远不会减少，high 的值永远不会增加，low 总是小于 high。
这个演示算法的一个大问题是它依赖于 C++ double 值来保存消息状态。 浮点变量的精度有限，这意味着最终，随着high-low之间的范围不断缩小，它们之间的距离变得太小而无法用浮点变量表示。 使用此处使用的模型，您可以编码 10 个左右的字符，但之后该算法将不起作用。

本文的其余部分将介绍一个<font color="brown">功能齐全的算法</font>。 从概念上讲，它看起来非常像已经提供的代码。 最大的区别在于，编码器和解码器中使用的变量 high、low 和 message 不再是 C++ 类型的 double。 相反，它们将是任意长的<font color="brown">二进制变量</font>。

为了让我们的程序处理任意长度的二进制数，它们将一次处理一位，读入位，执行计算，然后输出位，然后丢弃，因为不再需要它们。 如何完成这些的细节是令此算法发挥作用的工作。

除了这些修改之外，本文的其余部分将涵盖其他一些尚未提及的要点，包括：

- 如何处理流的结束。
- 如何从 [low, high) 范围内选择实际输出数。
- 为什么算术编码作为熵编码器优于霍夫曼编码。

### 第二部分

#### 无限精度（整数Math）

在第二部分中，您将不得不思考一些非常规的数学问题。 本文第一部分中描述的算法仍将忠实地执行，但将不再使用 double 类型的变量来实现。 它将改为使用整数变量和整数数学来实现，尽管是以有趣的方式。

我们实现的基本概念是：high、low和实际编码消息的值将是无限（unbounded）长度的二进制数。 换句话说，当我们完成对长篇小说《白鲸记》 的编码时，high和low将有数百万位长，而输出值本身也将有数百万位长。 这三个仍然代表一个大于或等于 0 且小于 1 的数字。

一个更有趣的方面是，即使算法流程中的三个数字有数百万位长，每次我们处理一个字符时，我们只会做一些简单的整数数学运算——32 位/64 位。

##### 数字表示

回想一下，在算法的参考版本中，low 和 high 是这样初始化的：

```cpp
double high = 1.0;
double low = 0.0;
```

在算法的整数版本中，我们切换到这样的表示：

```cpp
 unsigned int high = 0xFFFFFFFFU;
 unsigned int low = 0;
```

这两个数字都有一个隐含的小数点引导它们的值，这意味着`high`实际上是（十六进制）0.FFFFFFFF，或二进制，0.1111…1111，`low`是 0.0。 我们输出的数字在第一位之前同样会有一个隐含的小数点。

但这并不完全正确——在第一个实现中，`high` 是 1.0。 值 0.FFFFFFF 很接近，但只比 1.0 小一点。 这是如何处理的？

这是一些令人费解的数学发挥作用的地方。 虽然` high` 在内存中有 32 位，但我们认为它有一个无限长的二进制 1 尾随右端。 所以它不仅仅是 0.FFFFFFFF，那串 F（或 1）一直延伸到无穷大——它们就在那里，但还没有被转移到内存中。

同样，low 是 被认为是一个无限长的二进制字符串，0 挂在最后一个二进制位置。

**对熵模型的更改**
请记住，最终实现将完全使用整数数学来实现。 以前，该模型将概率作为一对浮点数返回，表示特定符号拥有的范围。

在算法的更新版本中，符号在数字线上仍然拥有大于等于 0 且小于 1 的特定范围。但是我们现在将使用一对分数来表示它们：`upper`/`denom`<font color="brown">(分母)</font>和` lower`/ `denom`。 这实际上并没有太多影响我们的模型代码。 我们在上一节中使用的示例模型返回了例如字符“W”的 .22 和 .23。 **现在，它会在一个名为 `prob` 的结构中返回 {22, 23, 100}。**

##### 真正的编码器——1st Pass

在进入最终的工作代码之前，我将展示一些实现基本算法的代码，但在实际问题上采取了一些捷径。 这段未完成的代码如下所示：

```cpp
unsigned int high = 0xFFFFFFFFU;
unsigned int low = 0;
char c;
while ( input >> c ) {
  int range = high - low + 1;
  prob p = model.getProbability(c);
  high = low + (range * p.upper)/p.denominator;
  low = low + (range * p.lower)/p.denominator;
  for ( ; ; ) {
    if ( high < 0x80000000U )
      output_bit( 0 );
    else if ( low >= 0x80000000U )
      output_bit( 1 );
    else
      break;
    low <<= 1;
    high << = 1;
    high |= 1;
  }
}
```

此循环的第一部分在概念上和功能上与第 1 部分中给出的浮点代码<font color="brown">相同</font>。我们得到`range` - 即`low`和`high`之间的差异，并将该`range`的一些子集分配给正在编码的字符 ，取决于从模型返回的概率。 <font color="brown">结果是 `low `变大了一点，` high `变小了一点。</font>

代码的第二部分更有趣一些。 <font color="brown">while 循环</font>是新的，它的作用也是新的——简化的浮点算法没有这样的东西。 它<font color="brown">对 `low` 和 `high` 执行范围检查</font>，寻找值具有相同最高有效位的情况。

第一个检查是查看`high`是否低于 0x80000000，在这种情况下，它的<font color="brown"> MSB（最高有效位）</font> 为 0。因为我们知道低位总是小于高位，所以它的 MSB 也将为 0。并且因为这两个值只会彼此更接近 ，两个值的 MSB 将永远为 0。

> 这里应该指的转为二进制后的最高有效位。0x8000..就是.1000000..小于它就只能是.<font color="brown">0</font>1111111..了

另一个范围检查查看`low` 是否增加到 0x7FFFFFFF 以上，在这种情况下，它和 high 的 MSB 值都为 1，并且 MSB 始终为 1。

在这两种情况中的任何一种情况下，请记住我们要处理三个不变量：`high`只减小，`low`只增大，`high`总是大于`low`。 所以一旦 high 的前导位为 0，它就永远不会改变。 一旦 low 的前导位为 1，它就永远不会改变。 如果是这种情况，我们可以将该位输出到<font color="brown"> 输出流</font>——我们 100% 确定它是什么，所以让我们将它移出到输出流并删除它。

在我们输出该位之后，我们将其 丢弃。 将`low`和`high`向左移动一位将<font color="brown">丢弃该 MSB</font>。 我们将 1 移入 high 的最低有效位，将 0 移入 low 的最低有效位。 因此，我们<font color="brown">通过排除不再对我们的计算精度有任何贡献的位来继续保持32 位运算</font>。 在这个特定的实现中，我们只在工作寄存器中保留 32 位，一些额外的数字已经发送到输出，还有一些其他数字等待输入。

下图显示了数学系统现在在某个压缩的中间是如何工作的。 即使我们使用的是 32 位数学，该算法现在也可以处理任意长版本的` high `和 `low`：

<img src="/Users/DevonnHou/Library/Application Support/typora-user-images/image-20221210210516710.png" alt="image-20221210210516710" style="zoom:36%;" />

当 `low` 和 `high` 收敛时，它们匹配的数字从左侧移出，大概是一个文件。 这些数字永远不会改变，并且不再需要作为计算的一部分。 同样，这两个数字都有无限数量的二进制数字，它们从右移入 ——`high`用1补充，`low`用0补充。

**致命缺陷和解决方法**
在刚刚提供的代码中，我们有一种非常合理的方法来管理创建任意长数字的计算。 这个实现很好，但并不完美。

当 `low `和 `high` 的值开始收敛于 0.5 的值，但<font color="brown">没有完全越过</font>会导致位被移出的线时，我们会遇到此算法的问题。 遇到此问题的一系列计算可能会产生如下值：

```cpp
low=7C99418B high=81A60145
low=7FF8F3E1 high=8003DFFA
low=7FFFFC6F high=80000DF4
low=7FFFFFF6 high=80000001
low=7FFFFFFF high=80000000
```

> 就是我们期望有high小于0.5，或者low大于等于0.5的情况，这样MSB之后能确定。但如果反过来，该情况不发生，high一直大于等于0.5，low小于0.5，<font color="brown">算法就一直没法触发丢弃MSB</font>。

我们的算法并没有完全按照我们的意愿行事。 数字越来越接近，但因为两者都没有越过 0.5 分频器，所以没有位被移出。 这个过程最终使这两个数字的值处于灾难性的境地。

为什么是灾难性的？ `range`的初始计算是通过从`high`减去`low`来完成的。 在此算法中，范围代表数轴。 随后的计算旨在为给定字符找到该值的正确子部分。 

但是，如果<font color="brown">算法就一直没法触发丢弃MSB</font>，没法移入LSB，我们对每个字符都执行相同的操作，则意味着解码器将无法将一个字符与另一个字符区分开来。

最终这可能会衰减到`low==high`的地步，这打破了我们的关键不变量之一。 我们很容易弄清楚此时会导致什么样的灾难。

下面的代码显示了对该算法的修复。 当`low`超过 0.5 或`high`低于 0.5 时，此版本的算法仍会执行单个位的正常输出。 但是当这两个值还没有收敛时，它会检查下一个MSB，看看我们是否正在走向接近收敛的问题。 当`high` 的两个最高有效位为 10，`low` 的两个最高有效位为 01 时就会出现这种情况。在这种情况下，我们知道这两个值正在收敛，但我们还不知道 最终的输出位将是什么。

##### 真正的编码器——2rd Pass

```cpp
unsigned int high = 0xFFFFFFFFU;
unsigned int low = 0;
int pending_bits = 0;
char c;
while ( input >> c ) {
  int range = high - low + 1;
  prob p = model.getProbability(c);
  high = low + (range * p.upper)/p.denominator;
  low = low + (range * p.lower)/p.denominator;
  for ( ; ; ) {
    if ( high < 0x80000000U ) {
      output_bit_plus_pending( 0 );
      low <<= 1;
      high << = 1;
      high |= 1;
    } else if ( low >= 0x80000000U ) {
      output_bit_plus_pending( 1 );
      low <<= 1;
      high << = 1;
      high |= 1;
    } else if ( low >= 0x40000000 && high < 0xC0000000U )
      pending_bits++;
      low << = 1;
      low &= 0x7FFFFFFF;
      high << = 1;
      high |= 0x80000001;
    } else
      break;
  }
}

void output_bit_plus_pending(bool bit, int &pending_bits)
{
  output_bit( bit );
  while ( pending_bits-- )
    output_bit( !bit );
}
```

> 除了high<0.5，low>=0.5，现在low>=0.25且high<0.75也做输出和移位。

那么当我们处于这种接近收敛的状态时，我们该怎么办呢？ 我们知道迟早，要么`high`会低于 0.5，要么`low`会超过0.5。 

> 从几何来理解，编码下一个字符会收缩子分段，移出MSB就是子分段只位于左/右半轴时，丢弃右/左半轴。

在第一种情况下，两个值的前导位均为 01，而在第二种情况下，它们的前导位均为 10。随着这种收敛的增加，前导位将扩展到 01111... 或 10000...，具有一些有限的数量 数字扩展。

> 临近收敛时，我们不知道收敛后最高位是0是1，但能肯定的是第二高位一定和最高位相反。相反的位的个数保留在`pending_bits`计数里。

鉴于此，我们知道一旦我们弄清楚字符串中的第一个二进制数字将是什么，后续位将全部相反。 所以在这个新版本的算法中，当我们处于接近收敛状态时，我们简单地丢弃`high`和`low`的<font color="brown">第二个最高有效位</font>，将剩余的位左移，同时保留 MSB。 这样做意味着还增加 pending_bits 计数器以确认我们需要在收敛最终发生时处理它。 下图显示了在低位挤压收敛位时的外观示例。 从高位移除该位基本上是相同的，但当然在此过程中将 1 移入 LSB。

<img src="/Users/DevonnHou/Library/Application Support/typora-user-images/image-20221211142340028.png" alt="image-20221211142340028" style="zoom:39%;" />

实现这一点的过程可能有点难以理解，但重要的是该过程必须遵守以下规则：

- `low`和`high`的低30位都左移一位。
- `low` 的最低有效位移入 0。
- `high`的最低有效位移入 1。
- 两者的 MSB 不变 - 运算后仍将其设置为 1（`high`）和 0（`low`）。

将所有这些结合在一起的最后一个变化是引入了新函数 `output_bit_plus_pending()`。 每次我们管理这个接近收敛的过程时，我们都知道另一位已被存储 - 我们不知道它是 1 还是 0。 我们<font color="brown">在 `pending_bits` 中保留所有这些连续位的计数</font>。 当我们最终达到可以输出实际 MSB 的情况时，我们就这样做，加上所有已存储的pending_bits。 当然，pending_bits将与正在输出的位相反。

这个固定版本的代码**完成了我们正确编码所需的一切**。 最终的工作 C++ 代码会有一些差异，但它们大多只是为了提高灵活性而进行的调整。 上面显示的代码或多或少是最终产品。

##### 真正的解码器

我已经讨论了这个算法中存在的一些不变量，但我跳过了一个：编解码一致。

这样做的结果是解码器中的代码最终看起来很像编码器中的代码。 `high`和`low`的操纵被有效地复制了。

两者之间的区别在于我们如何获得概率。 在编码器中，字符是已知的，因为我们直接从正在处理的文件中读取它。 在解码器中，必须通过查看我们正在解码的消息的值来确定字符 - 它落在 [0,1) 数字行上的位置。 模型的工作是在函数` getChar() `中解决这个问题。

压缩的输入被读入一个名为 `value`的变量。 这个变量是我们的另一个伪无限变量，就像`high`和`low`一样，主要区别在于在 LSB 位置移入它的内容——它移入来自编码消息的位。 因此，在任何给定时间，值都包含代表编码器创建的数字的长串中的 32 位。 <font color="brown">在 MSB 侧，计算中不再使用的位被移出值，而在 LSB 侧，当这些位移出时，消息的新位被移入。</font>

代码如下：

```cpp
unsigned int high = 0xFFFFFFFFU;
unsigned int low = 0;
unsigned int value = 0;
for ( int i = 0 ; i < 32 ; i++ ) {
  value <<= 1;
  value += m_input.get_bit() ? 1 : 0;
}
for ( ; ; ) {
  unsigned int range = high - low + 1;
  unsigned int count =  ((value - low + 1) * m_model.getCount() - 1) / range;
  int c;
  prob p = m_model.getChar( count, c );
  if ( c == 256 )
    break;
  m_output.putByte(c);
  high = low + (range*p.high)/p.count - 1;
  low = low + (range*p.low)/p.count;
  for( ; ; ) {
    if ( low >= 0x80000000U || high < 0x80000000U ) {
      low <<= 1;
      high <<= 1;
      high |= 1;
      value <<= 1;
      value += m_input.get_bit() ? 1 : 0;
    } else if ( low >= 0x40000000 && high < 0xC0000000U ) {
      low << = 1;
      low &= 0x7FFFFFFF;
      high <<= 1;
      high |= 0x80000001;
      value -= 0x4000000;
      value <<= 1;
      value += m_input.get_bit() ? 1 : 0;
    } else
      break;
  }
}
```

所以这段代码看起来与最终的编码器非常相似。 值的更新几乎相同 - 它添加了与`high`和`low`同步更新的`value`更新。 该算法的本质引入了另一个不变性：`value`将始终大于或等于`low`且小于`high`。



#### 示例实现

所有这些都放在 ari.zip 中的生产代码中。 （链接在本文末尾。）模板的使用使这段代码非常灵活，应该可以很容易地将它插入到您自己的应用程序中。 所有需要的代码都在头文件中，因此项目包含很简单。

在本节中，我将讨论需要组合在一起才能真正进行一些压缩的各种组件。 代码包有四个程序：

- fp_proto.cpp，浮点原型程序。 对实验有用，但对实际工作没有用。
- compress.cpp，它使用命令行参数压缩文件。
- decompress.cpp，它使用命令行参数解压缩文件。
- tester.cpp，它通过压缩/解压缩循环对文件进行测试，测试有效性，并输出压缩率。

感谢Nelson的[原文](https://marknelson.us/posts/2014/10/19/data-compression-with-arithmetic-coding.html)和[代码](https://marknelson.us/assets/2014-19-10-arithmetic-coding/ari.zip)。



